\section{表驱动}

\subsection{表驱动概述}

\subsubsection{表驱动介绍}
\begin{itemize}
    \item 表驱动法是一种编程模式(scheme)
    \begin{itemize}
        \item 从表里面查找信息而不使用逻辑语句(if和case)
    \end{itemize}
    \item 表驱动法适用于复杂的逻辑
    \item 表驱动法的另一个好处是可以将复杂逻辑从代码中独立出来，以便于单独维护
\end{itemize}

\subsubsection{表驱动示例}
使用复杂的逻辑对字符分类
\begin{lstlisting}
if ((('a' <= inputChar) && (inputChar <= 'z')) 
        || (('A' <= inputChar) && (inputChar <= 'Z'))) {
    charType = CharacterType.Letter;
}else if ((inputChar == ' ') || (inputChar == ',') ||
            (inputChar == '.') || (inputChar == '!') ||
            (inputChar == '(') || (inputChar == ')') ||
            (inputChar == ':') || (inputChar == ';') ||
            (inputChar == '?') || (inputChar == '-')){
    charType = CharacterType.Punctuation;
}else if (('0' <= inputChar) && (inputChar <= '9')) {
    charType = CharacterType.Digit;
}
\end{lstlisting}

使用查询表对字符分类：构造一个查询表，把每一个字符的类型保存在一个字符编码访问的数组
\begin{lstlisting}
chartype = charTypeTable[inputChar];
\end{lstlisting}

\subsubsection{使用表驱动法的两个问题}
在表里存放什么信息
\begin{itemize}
    \item 主要存放的是数据，但在一些特殊情况下也存放动作
\end{itemize}

如何快速从表中查询条目
\begin{itemize}
    \item 直接访问(Direct access)
    \item 索引访问(Indexed access)
    \item 阶梯访问(Stair-step access)
\end{itemize}

\subsection{直接访问}
所谓“直接访问”是指通过索引值（如下标）可以直接从表中找到对应的条目
\begin{lstlisting}
int[] daysPerMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
days = daysPerMonth(month-1);
\end{lstlisting}

\textbf{例：}假设你编写一个子程序，打印存储在一份文件中的消息
\begin{itemize}
    \item 通常该文件中会存储大约500条消息，而每份文件中会存有大约20种不同的消息。这些消息源自于一些浮标(Buoy)，提供有关水温、浮标位置等信息。
    \item 每一条消息都有若干字段，并且每条消息都有一个消息头，其中有一个ID，告诉你该消息属于这20多种消息中的哪一种。
    \item 这些消息的格式并不是固定不变的消息的存储方式消息头（ID确定了该消息所属的类型）
\end{itemize}

\begin{figure}[H]
    \setcounter{subfigure}{0}
	\centering
	\vspace{-0.5em}	
	\subfloat[消息的存储方式]{
	\begin{minipage}[t]{0.47\linewidth}
	\centering
	\includegraphics[width=0.97\linewidth]{images/消息的存储方式.png}
	\end{minipage}
	}
	\subfloat[消息的格式细节]{
	\begin{minipage}[t]{0.47\linewidth}
	\centering
	\includegraphics[width=0.97\linewidth]{images/消息的格式细节.png}
	\end{minipage}
	}
	\centering
	\vspace{-1em}
\end{figure}

\subsubsection{基于逻辑的方法}
读取每一条消息，检查其ID，然后调用一个用来阅读、解释以及打印一种消息的子程序
\begin{itemize}
    \item 消息阅读子程序包含一个循环，用来读入消息、解释其ID，以及根据该ID调用20个子程序中的某一个
    \item 如果你有20种消息，那么就要有20个子程序
    \item 每次有任何一种消息的格式变了，你就不得不修改负责处理该消息的子程序或者类的逻辑
\end{itemize}

基于逻辑方法所用的伪代码：
\begin{lstlisting}
While more messages to read
    Read a message header
    Decode the message ID from the message header
    If the message header is type 1 then
        Print a type 1 message
    Else if the message header is type 2 then
        Print a type 2 message
    ...
    Else if the message header is type 19 then
        Print a type 19 message
    Else if the message header is type 20 then
        Print a type 20 message
    End if
End While
\end{lstlisting}

\subsubsection{面向对象的方法}
问题的逻辑可以隐藏在对象继承结构里，但是基本结构还是同样复杂
\begin{lstlisting}
While more messages to read
    Read a message header
    Decode the message ID from the message header
    If the message header is type 1 then
        Instantiate a type 1 message object
    Else if the message header is type 2 then
        Instantiate a type 2 message object
    ...
    Else if the message header is type 19 then
        Instantiate a type 19 message object
    Else if the message header is type 20 then
        Instantiate a type 20 message object
    End if
End While
\end{lstlisting}

\subsubsection{表驱动法}
\begin{itemize}
    \item 消息阅读子程序由一个循环组成，该循环负责读入每一个消息头，对其ID解码，在Message 数组中查询其消息描述，然后每次都调用同一个子程序来解释该消息
    \item 只需要用一张表来描述每种消息的格式，而不用再把它们硬编码进程序逻辑里
\end{itemize}

\paragraph*{定义所有可能的字段类型}~{} \par
在定义消息表项之前先定义消息中可能出现的所有字段类型
\begin{lstlisting}
enum FieldType {
    FieldType_FloatingPoint,
    FieldType_Integer,
    FieldType_String,
    FieldType_TimeOfDay,
    FieldType_Boolean,
    FieldType_BitField,
    FieldType_Last = FieldType_BitField
};
\end{lstlisting}

\paragraph*{消息的表记录}~{} \par
\begin{figure}[H]
    \vspace{-0.5em}
	\centering
	\includegraphics[width=0.6\textwidth]{images/消息的表记录.pdf}
    \vspace{-1em}
\end{figure}

\paragraph*{表驱动法代码}~{} \par
表驱动法中最上层循环的伪代码，这部分的代码与前面的方法差别不大
\begin{lstlisting}
While more messages to read      
    Read a message header           
    Decode the message ID from the message header       
    Look up the message description in the message-description table
    Read the message fields and print them based on the message description
End While
\end{lstlisting}

\paragraph*{消息打印子程序}~{} \par
\begin{lstlisting}
While more fields to print
    Get the field type from the message description
    case (field type)
        of (floating point)
            read a floating-point value
            print the field label
            print the floating-point value
        of (integer)
            read an integer value
            print the field label
            print the integer value
        of (character string)
            read a character string
            print the field label
            print the character string
    …
    End Case
End While
\end{lstlisting}


\subsection{索引访问}
当无法直接从表中查询需要的条目时，就需要借助其他办法先获取表键值

索引访问的方法就是先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你感兴趣的主数据
\begin{itemize}
    \item 索引表是一种间接访问的技术
\end{itemize}

\textbf{例：}假设你经营着一家商店，有大约100种商品。再假设每种商品都有一个4位数字的物品编号，其范围是0000到9999
\begin{itemize}
    \item 如果用这个编号作为键值直接查询一张描述商品信息的表，那么就生成一个具有10000条记录的索引数组（从0到9999）
    \item 该数组中除了与你商店中的货物的标志相对应的100条记录以外，其余记录都是空的索引
\end{itemize}

\begin{figure}[H]
    \vspace{-0.5em}
	\centering
	\includegraphics[width=0.42\textwidth]{images/索引访问.png}
    \vspace{-1em}
\end{figure}

索引访问技术的主要优点：
\begin{itemize}
    \item 如果主查询表中的每一条记录都很大，那么索引数组就可以节省很多空间
    \begin{itemize}
        \item 一般而言索引表中的每条记录需要占用$2\sim 4$字节
    \end{itemize}
    \item 即使你用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表中的记录更方便更廉价
    \item 编写到表里面的数据比嵌入代码中的数据更容易维护
\end{itemize}


\subsection{阶梯访问}
阶梯访问方法不像索引结构那样直接，但是它要比索引访问方法节省空间

梯结构的基本想法：通过确定每项命中的阶梯层次确定其归类
\begin{figure}[H]
    \vspace{-0.5em}
	\centering
	\includegraphics[width=0.3\textwidth]{images/阶梯访问.png}
    \vspace{-1em}
\end{figure}


\begin{wraptable}{r}{4cm}
    \centering
    \vspace{-1.5em}
    \resizebox{6em}{!}{\begin{tabular}{|c|c|}
    \hline
    分值区间 & 等级 \\ \hline
    $\geq 90.0\%$ & A  \\ \hline
    $<90.0\%$ & B \\ \hline
    $<75.0\%$ & C \\ \hline
    $<65.0\%$ & D \\ \hline
    $<50.0\%$ & F \\ \hline
    \end{tabular}
    }
    \vspace{-1.5em}
\end{wraptable}

\textbf{例：}如果你正在开发一个等级评定的应用程序，按照如右图所示的等级区间对分数进行定级
\begin{itemize}
    \item 你不能用简单的数据转换函数来把表键值转换为A至F字母所代表的等级
    \item 用索引也不合适，因为这里用的是浮点数
\end{itemize}


选择使用阶梯方法：把每一区间的上限写入一张表里，然后写一个循环，按照各区间的上限来检查分数
\begin{lstlisting}
' set up data for grading table
Dim rangeLimit() As Double = {50.0, 65.0, 75.0, 90.0, 100.0}
Dim grade() As String = {"F", "D", "C", "B", "A"}
maxGradeLevel = grade.Length - 1
...
' assign a grade to a student based on the student's score
gradeLevel = 0
studentGrade = "A"
While (gradeLevel < maxGradeLevel)
    If (studentScore < rangeLimit(gradeLevel)) Then
        studentGrade = grade(gradeLevel)
    End If
        gradeLevel = gradeLevel + 1
Wend
\end{lstlisting}